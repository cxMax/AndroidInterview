# 数据结构

## 数组
* 数组是存放在连续内存空间上的相同类型数据的集合。
	* 数组下标都是从0开始的。
	* 数组内存空间的地址是连续的
* 因为数组的在内存空间的地址是连续的，所以我们在删除或者增添元素的时候，就难免要移动其他元素的地址。
数组的元素是不能删的，只能覆盖。

* 那么二维数组在内存的空间地址是连续的么？
	* 所以可以看出在C++中二维数组在地址空间上是连续的
	* Java是没有指针的，同时也不对程序员暴漏其元素的地址，寻址操作完全交给虚拟机


* 数组
	1. 内存中连续，因为是静态分配内存。
	2. 数组的缺点是，当数组长度发生变化时，原有的元素需要经过copy到新的数组中，这样性能有较大的损耗

##链表
* 链表几种类型 ：单链表、双链表、循环链表
* 链表的存储方式：数组是在内存中是连续分布的，但是链表在内存中可不是连续分布的。

* 链表
	1. 内存中不连续，他是动态分配内存。

## Java Stack缺陷
1. 当数组默认的容量发生改变时,原有的元素需要经过copy到新的数组中,因此pop、push的性能会有较大降低
2. 继承的是vector这个类，有add等方法，破坏了stack的api
	* 解决方案: <br>官方推荐使用 Deque(双端队列) 代替 Stack， 有链表和数组分别实现的。
		* 推荐使用LinkedList，单链表实现的栈，内存会占用更少

## 哈希表
> 哈希表一般用来快速判断一个元素是否出现在集合里


### 出现hash碰撞的情况 ？
* 对象的个数大于hash表的个数，此时计算hash函数计算得再均匀，也避免不了几个对象同时映射到一个索引下


### hashtable出现hash碰撞， 怎么来解决呢？
* 拉链法 - <br>发生冲突的元素，被存储在链表中；这个也是HashMap的做法


* 线性探测法 - <br>一定要保证tableSize大于dataSize。 我们需要依靠哈希表中的空位来解决碰撞问题；一般是+1，而且数据结构是数组的形式

### 常见的三种哈希结构
* 数组 - <br>可以拿数组当哈希表来用，但哈希值不要太大。使用数组来做哈希的题目，是因为题目都限制了数值的大小。而且如果哈希值比较少、特别分散、跨度非常大，使用数组就造成空间的极大浪费。


* set - <br>直接使用set 不仅占用空间比数组大，而且速度要比数组慢，set把数值映射到key上都要做hash计算的 , 输出结果中的每个元素一定是唯一的，也就是说输出的结果的去重的， 同时可以不考虑输出结果的顺序

当我们遇到了要快速判断一个元素是否出现集合里的时候，就要考虑哈希法了

* map - <br>判断是否出现、重复，就用hash表来解决， 这个map 主要是适应无序的场景， 有序肯定就要考虑数组了
使用map的空间消耗要比数组大一些的，因为map要维护红黑树或者哈希表，而且还要做哈希函数，是费时的！数据量大的话就能体现出来差别了。 所以数组更加简单直接有效！

## 二叉树

### 满二叉树
* 顾名思义，就是每一个层的结点数都达到最大值，则这个二叉树就是满二叉树。2^n -1个节点

### 完全二叉树 

* 在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置

* 之前我们刚刚讲过优先级队列其实是一个堆，堆就是一棵完全二叉树，同时保证父子节点的顺序关系。

### 二叉搜索树 
1. 有序树
2. 左节点<根节点<右节点
* 那么二叉搜索树采用中序遍历，其实就是一个有序数组。下二叉搜索树可是有序的

### 平衡二叉搜索树
* 左右节点高度差不能超过1


## 堆
> 堆是一颗完全二叉树，树中每个节点的值都不小于（或不大于）其左右孩子的值。

### 大顶堆 
* 堆头是最大元素

### 小顶堆 
* 堆头是最小元素

## List

### ArrayList : 
> ArrayList 是一个数组队列，相当于 动态数组

* ArrayList中的操作不是线程安全的！所以，建议在单线程中才使用ArrayList，而在多线程中可以选择Vector或者CopyOnWriteArrayList。
* 通过一个数组去保存数据的, 默认容量大小是10,新的容量=“(原始容量x3)/2 + 1”, 是将全部元素克隆到一个数组中。数组拷贝的方式
	* 3种遍历方式及效率 ：
		1. 迭代器遍历； 最低
		2. 随机访问，通过索引值去遍历；  最快
		3. for循环遍历； 跟get差不多

### LinkedList : 
> 通过双向链表去实现的

* Entry - <br>Entry是双向链表节点所对应的数据结构，它包括的属性有：当前节点所包含的值，上一个节点，下一个节点。不存在LinkedList容量不足的问题


* 7种遍历方式以及效率 ：
	1. 第一种，通过迭代器遍历。即通过Iterator去遍历。
	2. 通过快速随机访问遍历LinkedList
	3. 通过另外一种for循环来遍历LinkedList
	4. 通过pollFirst()来遍历LinkedList
	5. 通过pollLast()来遍历LinkedList
	6. 通过removeFirst()来遍历LinkedList
	7. 通过removeLast()来遍历LinkedList
		使用removeFist()或removeLast()效率最高， 只读不删除的话应该使用第3种遍历方式
		
* LinkedList和ArrayList在实际开发中内存占用
	* 一般情况下，LinkedList的占用空间更大，因为每个节点要维护指向前后地址的两个节点，但也不是绝对，如果刚好数据量超过ArrayList默认的临时值时，ArrayList占用的空间也是不小的，因为扩容的原因会浪费将近原来数组一半的容量，不过，因为ArrayList的数组变量是用transient关键字修饰的，如果集合本身需要做序列化操作的话，ArrayList这部分多余的空间不会被序列化

## Map
### WeakHashMap : 
* HashMap都是通过”拉链法"实现的散列表

### HashMap : 
* HashMap中的key-value都是存储在Entry数组中的, Node[] table。
* Node 这个数据结构是个单项链表。
* HashMap将“key为null”的元素都放在table的位置0处
	* “拉链法” - 当命中到同一位置之后, 会以链表的形式向后面链接, 在1.8, 当链表过长时, 会转化为红黑树, 增加查询的效率
	* 拉链法 - 主要为了解决hash冲突
	* HashMap在并发使用场景发生死循环 或 数据丢失。主要发生场景实在扩容的时候， 产生循环链表，出发死循环 


### HashTable : 
* 通过synchronized关键字实现线程安全
* HashTable虽然也是散列表, 通过拉链法解决"hash冲突",同样也是put<key, value>但跟HashMap还是有以下区别 :  
	* 遍历实现方式 : HashMap只支持Iterator, HashTable则支持Enumeration, Iterator
	* HashMap的key, 使用了"hash算法" ; 但是HashTable的key,则仅仅是Object.hashCode()。 

### ConcurrentHashMap : 

#### 为什么不用Hashtable和Collections.synchronizedMap(hashMap)
* 因为是对读写进行加锁操作，一个线程在读写元素，其余线程必须等待，性能可想而知
	* 1.6版本 :
		* 分段锁的机制，实现并发的更新操作，底层采用数组+链表+红黑树的存储结构
		* Segment : 继承ReentrantLock用来充当锁的角色，每个 Segment 对象守护每个散列映射表的若干个桶
		* HashEntry : 用来封装映射表的键 / 值对
		* 每个桶是由若干个 HashEntry 对象链接起来的链表
	* 1.8版本 :
		* 抛弃了Segment分段锁机制，利用CAS+Synchronized来保证并发更新的安全，底层依然采用node数组+链表+红黑树的存储结构,node代表key,value

#### 为什么使用红黑树 ?

* 把链表转化为红黑树，提高遍历查询效率
* 在1.8的实现中，当一个链表中的元素达到8个时，会调用treeifyBin()方法把链表结构转化成红黑树结构
	* 红黑树 : 
		* 相对接近平衡的二叉树
		* 每个节点要么红色，要么是黑色
		* 根节点一定是黑色
		* 每个空叶子节点必须是黑色
		* 如果一个节点是红色的，那么它的子节点必须是黑色
		* 从一个节点到该节点的子孙节点的所有路径包含相同个数的黑色节点
* ConcurrentHashMap 是一个并发散列映射表的实现，它允许完全并发的读取，并且支持给定数量的并发更新
* size()方法 : 
	* 1.7的实现 : (不准确的) 
		* 先采用不加锁的方式，连续计算元素的个数，最多计算3次： 			1. 如果前后两次计算结果相同，则说明计算出来的元素个数是准确的； 			2. 如果前后两次计算结果都不同，则给每个Segment进行加锁，再计算一次元素的个数；
	* 1.8的实现 :
		* 使用一个volatile类型的变量baseCount记录元素的个数
		* 元素个数保存baseCount中，部分元素的变化个数保存在CounterCell数组中
		* 通过累加baseCount和CounterCell数组中的数量，即可得到元素的总个数

### TreeMap : 
* TreeMap 也是哈希表，不过TreeMap中的“键-值对”是有序的，它是通过R-B Tree(红黑树)实现的；TreeMap不是线程安全的，只适用于单线程

* Iterator和Enumeration区别 ：
	* Iterator支持fail-fast机制，而Enumeration不支持
	* 在Vector、Hashtable实现Enumeration时，添加了同步

### HashSet :
* Set的实现类都是基于Map来实现的
* HashSet 是内部实现 , 是基于HashMap的
* 如何保证数据不重复？
	* HashSet的add()函数调用了HashMap的put, 先比较hashCode, 在比较equals函数, 因此一个Object需要重写hashCode和equals这两个函数


### TreeSet :
* TreeSet也是一个没有重复元素的集合，不过和HashSet不同的是，TreeSet中的元素是有序的；它是通过TreeMap实现的；TreeSet也不是线程安全的，只适用于单线程。
* 问TreeSet线程安全的实现两种方式 ? 
	* ConcurrentSkipListSet,这个东西是通过ConcurrentSkipListMap这个来实现的, 其内部实现是跳表, 非红黑树(ConcurrentHashMap)
	* Collections.synchronizedSortedSet, 所有这个类似api的实现方式都是底层SynchronizedCollection这个来实现的
* 问如何实现有序的 ? 
	* 其iterator遍历还是调用的TreeMap的遍历, 通过TreeMap实现有序遍历




## 引用
[当面试官问我ArrayList和LinkedList哪个更占空间时，我这么答让他眼前一亮](https://zhuanlan.zhihu.com/p/166686856)
